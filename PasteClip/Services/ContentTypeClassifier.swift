import AppKit
import UniformTypeIdentifiers

struct ContentTypeClassifier: Sendable {

    struct ClassifiedContent: Sendable {
        let contentType: ContentType
        let rawData: Data
        let textContent: String?
    }

    func classify(_ pasteboard: NSPasteboard) -> ClassifiedContent? {
        let types = pasteboard.types ?? []

        // Check for transient/concealed content (password managers, etc.)
        if types.contains(NSPasteboard.PasteboardType("org.nspasteboard.TransientType")) ||
           types.contains(NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType")) ||
           types.contains(NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")) {
            return nil
        }

        // Color
        if types.contains(.color), let color = NSColor(from: pasteboard) {
            let hex = color.hexString
            if let data = hex.data(using: .utf8) {
                return ClassifiedContent(contentType: .color, rawData: data, textContent: hex)
            }
        }

        // Image
        if let imageType = types.first(where: {
            [.tiff, .png].contains($0) ||
            $0.rawValue == "public.jpeg"
        }) {
            if let data = pasteboard.data(forType: imageType) {
                return ClassifiedContent(contentType: .image, rawData: data, textContent: nil)
            }
        }

        // File URL
        if types.contains(.fileURL),
           let urlString = pasteboard.string(forType: .fileURL),
           let url = URL(string: urlString) {
            let name = url.lastPathComponent
            if let data = urlString.data(using: .utf8) {
                return ClassifiedContent(contentType: .fileURL, rawData: data, textContent: name)
            }
        }

        // URL
        if types.contains(.URL),
           let urlString = pasteboard.string(forType: .URL) {
            if let data = urlString.data(using: .utf8) {
                return ClassifiedContent(contentType: .url, rawData: data, textContent: urlString)
            }
        }

        // HTML
        if types.contains(.html),
           let html = pasteboard.string(forType: .html) {
            if let data = html.data(using: .utf8) {
                let plainText = pasteboard.string(forType: .string)
                return ClassifiedContent(contentType: .html, rawData: data, textContent: plainText ?? html)
            }
        }

        // Rich Text (RTF)
        if types.contains(.rtf),
           let data = pasteboard.data(forType: .rtf) {
            let plainText = pasteboard.string(forType: .string)
            return ClassifiedContent(contentType: .richText, rawData: data, textContent: plainText)
        }

        // Plain Text (also handles URLs pasted as text)
        if let text = pasteboard.string(forType: .string), !text.isEmpty {
            if let data = text.data(using: .utf8) {
                // Check if text is actually a URL
                if let url = URL(string: text), url.scheme != nil, url.host != nil {
                    return ClassifiedContent(contentType: .url, rawData: data, textContent: text)
                }
                return ClassifiedContent(contentType: .plainText, rawData: data, textContent: text)
            }
        }

        return nil
    }
}

extension NSColor {
    var hexString: String {
        guard let rgb = usingColorSpace(.sRGB) else { return "#000000" }
        let r = Int(rgb.redComponent * 255)
        let g = Int(rgb.greenComponent * 255)
        let b = Int(rgb.blueComponent * 255)
        return String(format: "#%02X%02X%02X", r, g, b)
    }

    static func fromHex(_ hex: String) -> NSColor? {
        let cleaned = hex.trimmingCharacters(in: CharacterSet(charactersIn: "#"))
        guard cleaned.count == 6,
              let rgb = UInt64(cleaned, radix: 16) else { return nil }
        return NSColor(
            red: CGFloat((rgb >> 16) & 0xFF) / 255,
            green: CGFloat((rgb >> 8) & 0xFF) / 255,
            blue: CGFloat(rgb & 0xFF) / 255,
            alpha: 1.0
        )
    }
}
